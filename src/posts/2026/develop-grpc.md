---
title: Изобретая grpc
author: kafkiansky
date: 2026-01-08
tags:
  - php
  - grpc
draft: false
---

Хотя `grpc` тесно ассоциирован с `protobuf` как часть одного фреймворка, они друг с другом незнакомы. Настолько, что вместо `protobuf` могли быть `msgpack`, упомянутый выше `avro` или даже `json` — и мир для `grpc` не изменился бы. В отличие от `amqp`, протоколов `cassandra`, `kafka` и некоторых других систем, которые, на самом деле, объединяют в себе протоколы общения и сериализации, `grpc` как транспорт оборачивает `protobuf` сообщения в собственный бинарный протокол.

При этом самостоятельным транспортом `grpc` назвать тоже трудно — он работает на `http/2`, используя всего один бинарный фрейм, куда входят флаг, указывающий, сжато сообщение, например в `gzip`, или нет, размер `protobuf` сообщения и само сообщение — то есть от себя `grpc` добавляет всего 5 байт: 1 байт на флаг и остальные 4 на длину сообщения. При этом следуя стандартам сетевой передачи данных, байты передаются в `big endian` порядке.

Может показаться, что использование `http` протокола не является преимуществом по сравнению с привычным для многих `http api`, чтобы использовать `grpc`, если есть `openapi` стандарт, для которого также существуют какие-никакие (для `php` это больше "никакие") генераторы кода. Стоит понимать, что, хотя `http/2` и является наследником `http` и использует большинство из его концепций, это все-таки другой, правильный, протокол. Такой, каким современный протокол должен быть.

Если не говорить про `http/1`, главный недостаток которого — закрытие соединения после каждого запроса — исправил `http/1.1`, даже он не смог избавиться от всех родовых травм этого протокола. И текстовый формат, если вы подумали про него, — не самая большая из них. В конце концов, есть текстовые протоколы вроде `nats` и `redis`, которые по производительности не уступают бинарным. Серьезной проблемой является синхронность этого протокола: нельзя отправить два запроса *параллельно*[^1] по одному соединению. Ради масштабирования приходится использовать пул соединений, который значительно дороже и ограниченнее мультиплексирования запросов через стримы, предлагаемых `http/2`. `grpc` не стал прятать `http/2`, а сделал его стримы — одно из главных преимуществ этого протокола — частью фреймворка, что доступно прямо в схеме определения сервисов. 

Все запросы в `grpc` отправляются методом `POST`, а путь запроса состоит из названия пакета, если он указан, названия сервиса и `rpc`. Для такой схемы путем будет `/test.api.v1.SomeController/DoSome`:
```
package test.api.v1;

import "google/protobuf/empty.proto";

service SomeController {
  rpc DoSome(google.protobuf.Empty) returns (google.protobuf.Empty);
}
```

---

[^1]: тут долго можно спорить, что называть параллелизмом при работе с сетью, потому что в конечном итоге все упирается в строго упорядоченный `tcp`, проблемы которого уже решает следующая версия `http` — `http/3`, работающий на `quic`. Я же больше подразумеваю параллелизм на стороне сервера, а не сокета, один медленный запрос к которому не заблокирует целое соединение. 
